For a project, here's a README.md:

```
# Construction Timelapse Generator

The code in this project was entirely generated by ChatGPT-4, as well as (most of)
this README.

Construction Timelapse Generator is a Python script that creates timelapse videos
from a series of webcam photos taken at specified intervals. The script handles
copying photos from a source directory, processing them, and creating a high-quality
timelapse video using the powerful ffmpeg library.

## Features

- Automatically calculates sunrise and sunset times for each day based on the date
- Allows custom start and end times for each day
- Supports multiple days of photos
- Generates a 1080p, 60fps H.264 video

## Requirements

- Python 3
- ffmpeg
- rsync

## Installation

1. Clone the repository or download the script to your local machine.

```
git clone https://github.com/dag10/timelapse.git
```


2. Make sure you have Python 3, ffmpeg, and rsync installed on your system.

3. Create a virtual environment and activate it:

```
python3 -m venv venv
source venv/bin/activate
```

4. Install the required dependencies:

```
pip3 install -r requirements.txt
```

## Usage

1. Edit the script to set the source directory where your webcam photos are stored.

2. Run the script with the desired options:

```
python3 timelapse.py --date 2023-03-27 --days 1 --start 07:30 --end 19:30
```

### Command-line arguments

| Argument   | Description | Default | Format |
|------------|-------------|---------|--------|
| `--date`   | The first date to copy photos from | most recent Monday | `YYYY-MM-DD` |
| `--days`   | The number of days from the `--date` to copy photos from, inclusive | 5 | integer |
| `--start`  | The time of the first photo to copy for each day, inclusive | one hour before sunrise | 24hr format |
| `--end`    | The time of the last photo to copy for each day, inclusive | one hour after sunset | 24hr format |
| `--no-video` | If set, the script will only transfer files and not create a timelapse video | N/A | flag |
| `--no-copy`  | If set, the script will not transfer files, assuming they're already transferred | N/A | flag |

## To set up Youtube uploading

1. Follow the *Installation* steps to set up and enter the virtual env, with the requirements installed.

2. Go to the [Google Cloud Console](https://console.cloud.google.com/) and follow
these steps to obtain the `client_id`, `client_secret`, and `refresh_token`:

3. If you don't have a project, create a new one by clicking the "Select a project" dropdown in the top right corner and then the "New Project" button. If you already have a project, you can use it.

4. With your project selected, click on "APIs & Services" in the left-hand menu, then click on "Dashboard".

5. Click the "+ ENABLE APIS AND SERVICES" button at the top of the page.

6. In the API Library, search for "YouTube Data API v3" and click on it, then click "Enable".

7. After enabling the API, click on "Create Credentials" at the top of the page.

8. In the "Add credentials to your project" form, select "YouTube Data API v3" for "Which API are you using?", select "Other non-UI (e.g. cron job, daemon)" for "Where will you be calling the API from?", and choose "Application data" for "What data will you be accessing?". Click "What credentials do I need?".

9. Create an OAuth 2.0 client ID by giving it a name (e.g., "YouTube Uploader") and click "Create". Your client_id and client_secret will be shown. Save them for later use.

10. Click "Done".

11. On the "Credentials" page, you'll see the OAuth 2.0 Client ID you just created. Click the pencil icon to edit it.

12. Click "Download" to download the JSON file containing your client credentials. Rename this file to `client_secret.json` and move it to this project directory.

13. Now, you need to obtain the `refresh_token`. To do this, you'll need to authorize your application to access your YouTube account. Run the `get_refresh_token.py` script:

```
python4 get_refresh_token.py
```

14. A browser window should open, prompting you to sign in to your Google account and allow the application to access your YouTube account. After granting access, the script will save the refresh_token (along with client_id and client_secret) to the config.json file.
```

Here's the current timelapse.py:
```
import argparse
import datetime
import os
import re
import subprocess
import sys
import tempfile
from sun import calculate_sunrise, calculate_sunset
from youtube import upload_to_youtube
from googleapiclient.errors import ResumableUploadError

# Constants
BASE_DIR = "/Volumes/DrewHA/Webcam/"
PLAYLIST_ID = "PLnZFyIYD4hEnHwQw7_4GVGhtO-Qk8iXtt"
VIDEO_TITLE_FORMAT = "{start_date} - {end_date} Construction Timelapse"

def datetime_range(start, end, delta):
    current = start
    while current <= end:
        yield current
        current += delta

def get_recent_monday():
    today = datetime.date.today()
    return today - datetime.timedelta(days=today.weekday())

def confirm(prompt):
    while True:
        response = input(prompt).lower()
        if response in ["y", "yes", ""]:
            return True
        elif response in ["n", "no"]:
            return False

parser = argparse.ArgumentParser(description="Create timelapse from webcam photos")
parser.add_argument("--date", type=str, default=get_recent_monday().strftime("%Y-%m-%d"), help="First date to copy photos from (default: most recent Monday)")
parser.add_argument("--days", type=int, default=5, help="Number of days from the --date to copy photos from, inclusive (default: 5)")
parser.add_argument("--start", type=str, help="Time of the first photo to copy for each day, inclusive (24hr format)")
parser.add_argument("--end", type=str, help="Time of the last photo to copy for each day, inclusive (24hr format)")
parser.add_argument("--no-video", action="store_true", help="Don't create timelapse video")
parser.add_argument("--no-copy", action="store_true", help="Don't transfer files, assume they're already transferred")
parser.add_argument("--no-upload", action="store_true", help="Don't upload the video to YouTube")
args = parser.parse_args()

start_date = datetime.datetime.strptime(args.date, "%Y-%m-%d").date()
end_date = start_date + datetime.timedelta(days=args.days - 1)
dest_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), f"{start_date.strftime('%Y_%m_%d')}-{end_date.strftime('%Y_%m_%d')}")
stills_dir = os.path.join(dest_dir, "stills")

if not os.path.exists(dest_dir):
    os.makedirs(dest_dir)
if not os.path.exists(stills_dir):
    os.makedirs(stills_dir)

print(f"Destination directory: {dest_dir}")

total_files_transferred = 0
for i in range(args.days):
    date = start_date + datetime.timedelta(days=i)
    date_str = date.strftime("%Y-%m-%d")
    src_dir = f"{BASE_DIR}{date_str}"

    if not args.start:
        sunrise = calculate_sunrise(date)
        sunrise_time = datetime.datetime.strptime(sunrise, "%H:%M")
        args.start = (sunrise_time - datetime.timedelta(hours=1)).strftime("%H:%M")
    if not args.end:
        sunset = calculate_sunset(date)
        sunset_time = datetime.datetime.strptime(sunset, "%H:%M")
        args.end = (sunset_time + datetime.timedelta(hours=1)).strftime("%H:%M")

    if not args.no_copy:
        print(f"Syncing photos for {date_str} between {args.start} and {args.end}")

        include_patterns = [f"01_{date_str}_{t.hour:02d}-{t.minute:02d}-??.jpg" for t in datetime_range(datetime.datetime.strptime(args.start, "%H:%M"), datetime.datetime.strptime(args.end, "%H:%M"), datetime.timedelta(minutes=1))]
        include_args = [f"--include={pattern}" for pattern in include_patterns]

        rsync_cmd = ["rsync", "-av", "--no-relative", *include_args, "--exclude=*", f"{src_dir}/", stills_dir]
        #print(f"Running rsync: {' '.join(rsync_cmd)}")
        result = subprocess.run(rsync_cmd, capture_output=True, text=True)

        if result.returncode != 0:
            print(f"Error: {result.stderr}", file=sys.stderr)
            sys.exit(1)

        # Parse the output to get the number of transferred files
        transferred_files = len(re.findall(r"01_\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}.jpg", result.stdout))
        total_files_transferred += transferred_files
        print(f"Transferred {transferred_files} files for {date_str}")

print(f"Total files transferred: {total_files_transferred}")

# Create timelapse using ffmpeg
video_filename = f"timelapse_{os.path.basename(dest_dir)}.mov"
video_path = os.path.join(dest_dir, video_filename)

if not args.no_video:
    # Read and sort the filenames
    input_files = sorted(os.listdir(stills_dir))

    # Create a temporary file with the sorted filenames
    with tempfile.NamedTemporaryFile("w", delete=False) as temp_file:
        for file in input_files:
            temp_file.write(f"file '{os.path.join(stills_dir, file)}'\n")

    ffmpeg_cmd = [
        "ffmpeg", "-y", "-r", "60", "-f", "image2", "-s", "1920x1080", "-i", f"{stills_dir}/%*.jpg",
        "-c:v", "libx264", "-crf", "18", "-pix_fmt", "yuv420p", video_path
    ]

    print(f"Running ffmpeg: {' '.join(ffmpeg_cmd)}")
    result = subprocess.run(ffmpeg_cmd, capture_output=True, text=True)

    if result.returncode != 0:
        print(f"Error: {result.stderr}", file=sys.stderr)
        sys.exit(1)

    print(f"Timelapse video created: {video_path}")

    # Open the video using the system's 'open' command
    open_cmd = ["open", video_path]
    subprocess.run(open_cmd)

if not args.no_upload:
    if confirm("Do you want to upload the video to YouTube? [Y/n]: "):
        # Find thumbnail for the first day's midpoint
        first_day_midpoint = (datetime.datetime.combine(datetime.date.today(), datetime.datetime.strptime(args.start, "%H:%M").time()) + (datetime.datetime.strptime(args.end, "%H:%M") - datetime.datetime.strptime(args.start, "%H:%M")) // 2).time()
        thumbnail_filename = f"01_{start_date.strftime('%Y-%m-%d')}_{first_day_midpoint.hour:02d}-{first_day_midpoint.minute:02d}-00.jpg"
        thumbnail_path = os.path.join(stills_dir, thumbnail_filename)
        print(f"Using thumbnail: {thumbnail_path}")

        # Upload the video to YouTube
        video_title = VIDEO_TITLE_FORMAT.format(start_date=start_date.strftime("%Y.%m.%d"), end_date=end_date.strftime("%Y.%m.%d"))
        print(f"Uploading video to YouTube with title: {video_title}")
        try:
            video_id = upload_to_youtube(video_path, video_title, thumbnail_path, PLAYLIST_ID)
        except ResumableUploadError as e:
            print(f"Failed to upload video due to error: {e}")
            sys.exit(1)

        if video_id:
            print(f"Video uploaded successfully. Video ID: {video_id}")
        else:
            print("Failed to upload video.", file=sys.stderr)
            sys.exit(1)
```

Are there any updates we need to make to the README.md?
